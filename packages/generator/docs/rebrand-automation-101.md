# Rebrand Automation 101 (Blueprint + Generator)

This guide is the **entry-level onboarding** for teams and agents working with UI8Kit rebranding automation.

It explains:

- what each tool does;
- how the tools fit together;
- what to run first;
- how to safely evolve an existing DSL app into a new branded app.

If you are new to this workflow, start here before using advanced docs.

---

## 1. What problem this solves

In a real rebrand, you usually change all of this at once:

- data (`fixtures/*.json`);
- routes (`src/App.tsx`, `src/routes/**/*`);
- page views (`src/blocks/**/*View.tsx`);
- types (`src/types/*.ts`, `src/data/adapters/types.ts`);
- context wiring (`src/data/context.ts`, adapters);
- navigation (`fixtures/shared/navigation.json`);
- app identity (name, domain, style tokens).

Without automation, these updates drift and break contracts.

The rebrand system adds:

1. **Blueprint (`blueprint.json`)** — machine-readable source of truth.
2. **Scanner (`blueprint:scan`)** — generates blueprint from code.
3. **Validator (`blueprint:validate`)** — detects structural drift.
4. **Dependency Graph (`blueprint:graph`)** — shows cross-file links.
5. **Scaffolder (`scaffold entity`)** — safely adds new entities.
6. **Contract tests** — verifies fixtures/types/routes stay aligned.

Think of it as:

- **map** = blueprint,
- **compass** = validator report,
- **route plan** = dependency graph.

---

## 2. Core concepts (must know)

### 2.1 Blueprint

`blueprint.json` lives in each DSL app root (`apps/<app>/blueprint.json`) and describes:

- entities;
- fixture files;
- type files;
- routes + route files;
- views;
- layouts, partials, domains;
- context and navigation sources.

It is regenerated by scanner and used by validator/graph/contracts.

### 2.2 Additive scaffolding

`scaffold entity` is **additive** by design:

- creates missing files for a new entity;
- updates context, adapter, navigation, route registry;
- never auto-deletes old entities.

Deletion and deprecation should be a separate controlled step.

### 2.3 Route normalization

For lower cognitive load, dynamic routes should use `:slug` consistently:

- ✅ `/menu/:slug`
- ✅ `/promotions/:slug`
- ❌ `/menu/:id` mixed with `/blog/:slug`

---

## 3. Prerequisites and preparation checklist

Before running rebrand automation:

1. Open target app folder (example: `apps/dsl`).
2. Ensure required source files exist:
   - `src/App.tsx`
   - `src/data/context.ts`
   - `src/data/adapters/types.ts`
   - `src/data/adapters/fixtures.adapter.ts`
   - `fixtures/shared/navigation.json`
3. Ensure entity fixtures have collections (`items` or `posts`) and IDs/slugs.
4. Ensure navigation points to existing list routes.
5. Ensure TypeScript type files export entity types.

Recommended preflight:

```bash
# from app root (example: apps/dsl)
bun run lint:dsl
bun run validate
```

---

## 4. Command reference (Generator + Rebrand)

All commands below are CLI commands from `@ui8kit/generator`.

### 4.1 Existing generator commands

```bash
bunx ui8kit-generate react --cwd apps/dsl
bunx ui8kit-generate static --cwd apps/react --config dist.config.json
bunx ui8kit-generate html --cwd apps/react --config dist.config.json
bunx ui8kit-generate styles --cwd apps/react --config dist.config.json
```

### 4.2 Rebrand automation commands

```bash
# 1) Generate/update blueprint from real sources
bunx ui8kit-generate blueprint:scan --cwd apps/dsl

# 2) Validate integrity against blueprint
bunx ui8kit-generate blueprint:validate --cwd apps/dsl

# 3) Build dependency graph
bunx ui8kit-generate blueprint:graph --cwd apps/dsl

# 4) Add a new entity (additive)
bunx ui8kit-generate scaffold entity \
  --cwd apps/dsl \
  --name contacts \
  --singular Contact \
  --fields "name:string,email:string,company:string,status:active|archived" \
  --routes "/contacts,/contacts/:slug"
```

---

## 5. Standard rebrand workflow (recommended)

Use this loop for each rebrand iteration:

1. **Scan** current app:
   - `blueprint:scan`
2. **Add new entities**:
   - `scaffold entity` (one or multiple entities)
3. **Fill content and UI**:
   - update fixtures, views, labels, brand metadata
4. **Validate structure**:
   - `blueprint:validate`
5. **Inspect relationships**:
   - `blueprint:graph`
6. **Run contracts**:
   - app-level contract test script
7. **Generate target app output**:
   - `dist:app` or equivalent app pipeline

Repeat until validator + contracts are clean.

---

## 6. What each tool validates

`blueprint:validate` covers:

- fixture exists and parses as JSON;
- declared collection key exists (`itemsKey`);
- item-level required keys (`id`, `slugField`);
- type file exists and exports declared singular type;
- fixture type is present in adapter type system;
- context and CanonicalContextInput reference entity fixture;
- declared routes are present in `App.tsx`;
- declared route/view files exist on disk;
- list routes are present in navigation;
- no orphan fixtures/routes/views for known entity scope;
- declared domains exist in context domains.

Reports are written to:

- `.cursor/reports/blueprint-validation.json`
- `.cursor/reports/blueprint-validation.md`

---

## 7. Understanding the dependency graph

`blueprint:graph` generates `dependency-graph.json` with:

- nodes (fixture, adapter, context, route, view, component, type, partial);
- typed edges (`fixture -> adapter -> context -> route -> view ...`);
- Mermaid diagram text for quick visual rendering.

Use graph data to answer:

- “What breaks if we rename entity X?”
- “Which views depend on this fixture?”
- “Which partials are driven by navigation?”

---

## 8. Example: migrate to CRM-like structure

Goal: evolve from restaurant-oriented model to CRM-oriented model while preserving contracts.

Minimal sequence:

```bash
# scan current state
bunx ui8kit-generate blueprint:scan --cwd apps/dsl

# add CRM entities (additive)
bunx ui8kit-generate scaffold entity --cwd apps/dsl --name contacts --singular Contact --fields "name:string,email:string,status:lead|customer" --routes "/contacts,/contacts/:slug"
bunx ui8kit-generate scaffold entity --cwd apps/dsl --name deals --singular Deal --fields "title:string,value:number,status:open|won|lost" --routes "/deals,/deals/:slug"
bunx ui8kit-generate scaffold entity --cwd apps/dsl --name tasks --singular Task --fields "title:string,owner:string,status:todo|doing|done" --routes "/tasks,/tasks/:slug"

# validate + graph
bunx ui8kit-generate blueprint:validate --cwd apps/dsl
bunx ui8kit-generate blueprint:graph --cwd apps/dsl
```

Then replace visual/content semantics in blocks/fixtures/routes while using validator as guardrail.

---

## 9. Safe operating rules for LLM agents and teams

1. Always run `blueprint:scan` before structural edits.
2. Do not manually edit `blueprint.json` first; regenerate it from source.
3. Keep dynamic route params normalized to `:slug`.
4. Prefer additive scaffolding for new domains/entities.
5. After each structural change:
   - run `blueprint:validate`;
   - inspect `.cursor/reports/*`;
   - run contracts.
6. Keep comments and docs in English for shared international teams.

---

## 10. Typical failure modes and quick fixes

### `ENTITY_TYPES_FILE_MISSING`

Create the missing file in `src/types/<entity>.ts` and export the declared singular type.

### `ENTITY_ROUTE_NOT_REGISTERED`

Add missing `<Route path="...">` in `src/App.tsx` and ensure import points to route file.

### `ENTITY_NAV_LINK_MISSING`

Add list route (`/<entity>`) to `fixtures/shared/navigation.json`.

### `ENTITY_ROUTE_PARAM_NOT_NORMALIZED`

Replace `:id` with `:slug` and update route consumers (`useParams`, link builders, lookup logic).

### `ORPHAN_FIXTURE` or `ORPHAN_VIEW`

Either:
- register entity properly (preferred), or
- remove obsolete files in a dedicated cleanup pass.

---

## 11. Next reading

After this 101 guide:

- `../GUIDE.md` — generator runtime modes and troubleshooting.
- `../README.md` — package overview and quick commands.
- `./transformer.md` — JSX -> HAST internals.
- `./template-plugins.md` — template engine plugin track.
